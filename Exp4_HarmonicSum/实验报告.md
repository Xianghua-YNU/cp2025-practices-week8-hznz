# 实验四：调和级数求和顺序与舍入误差实验报告

## 1. 实验目的
1. 实现并比较两种调和级数求和方法
2. 量化分析不同求和顺序导致的计算结果差异
3. 理解浮点数舍入误差的累积效应
4. 探究求和顺序对数值计算精度的影响

## 2. 实验原理
### 2.1 调和级数部分和
调和级数的前N项和定义为：

$$ S_N = \sum_{n=1}^{N} \frac{1}{n} $$

### 2.2 两种求和方法
1. 从小到大求和（ $S^{(up)}$）：

$$ S^{(up)} = \sum_{n=1}^{N}\frac{1}{n} = \frac{1}{1} + \frac{1}{2} + \frac{1}{3} + \cdots + \frac{1}{N} $$

2. 从大到小求和（ $S^{(down)}$）：

$$ S^{(down)} = \sum_{n=N}^{1}\frac{1}{n} = \frac{1}{N} + \frac{1}{N-1} + \cdots + \frac{1}{2} + \frac{1}{1} $$

### 2.3 相对差异计算
两种方法的相对差异定义为：

$$ \delta = \frac{|S^{(up)} - S^{(down)}|}{|(S^{(up)} + S^{(down)}) / 2|} $$

## 3. 实验方法
### 3.1 代码实现
- 实现 `sum_up(N)` 函数，从小到大计算调和级数和
- 实现 `sum_down(N)` 函数，从大到小计算调和级数和

### 3.2 数据收集
对不同的N值进行计算：
1. N值选取：使用 `np.logspace(1, 4, 50)` 在对数尺度上均匀取点
2. 计算并记录相对差异

## 4. 实验结果
### 4.1 数据记录

N值      正向求和        逆向求和        相对差异
-------------------------------------------------------
10       2.928968        2.928968        0.000e+00
100      5.187378        5.187378        2.118e-16
1000     7.485471        7.485471        1.554e-16
10000    9.787606        9.787606        1.110e-16

### 4.2 误差分析图
（在此插入相对差异δ随N变化的双对数图）
![image](https://github.com/user-attachments/assets/d89b4c23-4830-4551-be37-1cce7371afe6)

## 5. 分析与讨论
### 5.1 结果分析
1. 相对差异随N的变化趋势：
   - （分析图表趋势）

2. 舍入误差累积效应：
   - （分析为什么 $S^{(down)}$更精确）
   - （结合浮点数表示方式解释）

### 5.2 误差来源分析
1. 浮点数表示精度限制
2. 加法运算中的舍入
3. 求和顺序的影响

## 6. 结论
（总结实验发现，特别是关于求和顺序对计算精度的影响）
1、求和顺序显著影响数值精度：逆向求和（从大到小） 更优。

2、随着 N 增大，正向求和的舍入误差累积更明显。

3、实际应用中，应优先选择从大到小的累加顺序以提高精度。
## 7. 思考题
1. 为什么从大到小求和通常能获得更好的精度？
先累加小项可以减少大数与小数的指数对齐误差
2. 在实际应用中，如何选择合适的求和策略来减小舍入误差？
优先累加数量级相近的项，或使用高精度数据类型
3. 除了改变求和顺序，还有什么方法可以提高数值计算的精度？
分段求和、Kahan 求和算法或使用补偿求和技巧。
## 附录：关键代码
```python
# 在此粘贴关键代码实现
```
# harmonic_sum.py
import numpy as np
import matplotlib.pyplot as plt

def sum_up(N):
    """【正向求和】从小到大计算调和级数前N项和（1 + 1/2 + ... + 1/N）"""
    sum_val = 0.0  # 初始化和值
    # 从1到N遍历，逐个加上当前项的倒数
    for i in range(1, N + 1):
        sum_val += 1.0 / i
    return sum_val

def sum_down(N):
    """【逆向求和】从大到小计算调和级数前N项和（1/N + ... + 1/2 + 1）"""
    sum_val = 0.0  # 初始化和值
    # 从N到1倒序遍历，逐个加上当前项的倒数
    for i in range(N, 0, -1):
        sum_val += 1.0 / i
    return sum_val

def calculate_relative_difference(N):
    """计算两种求和方法的相对差异"""
    s_up = sum_up(N)    # 获取正向求和结果
    s_down = sum_down(N) # 获取逆向求和结果
    avg = (s_up + s_down) / 2  # 计算平均值作为分母
    # 处理分母为零的特殊情况
    return abs(s_up - s_down) / avg if avg != 0 else 0.0

def plot_differences():
    """绘制相对差异随N变化的双对数坐标图"""
    # 生成对数分布的N值（10^1到10^4共50个点）
    N_values = np.logspace(1, 4, 50, dtype=int)
    unique_N = np.unique(N_values)  # 去除重复值
    
    # 计算每个N对应的相对差异
    deltas = [calculate_relative_difference(N) for N in unique_N]
    
    # 配置绘图参数
    plt.figure(figsize=(10, 6))
    # 绘制红色圆点连线图，点大小为4，线宽1
    plt.loglog(unique_N, deltas, 'ro-', markersize=4, linewidth=1)
    plt.xlabel("N值（对数坐标）", fontsize=12)
    plt.ylabel("相对差异（对数坐标）", fontsize=12)
    plt.title("调和级数求和顺序差异分析", fontsize=14)
    plt.grid(True, which="both", linestyle="--", alpha=0.6)  # 添加网格线
    plt.tight_layout()  # 自动调整布局
    plt.show()

def print_results():
    """打印典型N值的计算结果"""
    N_values = [10, 100, 1000, 10000]
    # 打印表头
    print("\nN值      正向求和        逆向求和        相对差异")
    print("-" * 55)
    # 遍历每个N值计算结果
    for N in N_values:
        s_up = sum_up(N)
        s_down = sum_down(N)
        delta = calculate_relative_difference(N)
        # 格式化输出：N值左对齐，数值保留6位小数，差异用科学计数法显示
        print(f"{N:<8} {s_up:<16.6f} {s_down:<16.6f} {delta:.3e}")

def main():
    """主执行流程"""
    print_results()   # 打印关键结果
    plot_differences()  # 生成差异分析图

if __name__ == "__main__":
    main()
